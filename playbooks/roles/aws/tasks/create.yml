---
- name: Select latest RHEL8 AMI
  set_fact:
    vpc: >-
      {{ vpc | default({}) | combine({ item: base_vpc }) }}
  loop: "{{ regions }}"
  when: vpc.keys() | length > 0

- name: Find RHEL8 AMIs
  ec2_ami_info:
    region: "{{ item }}"
    filters:
      name: RHEL-8.6.0_HVM-*
      architecture: x86_64
      root-device-type: ebs
      virtualization-type: hvm
  loop: "{{ vpc | list }}"
  register: rhel8_amis

- name: Select latest RHEL8 AMI
  set_fact:
    latest_ami: >-
      {{ latest_ami | default({}) 
          | combine( { item.invocation.module_args.region: 
            item.images
              | sort(attribute='creation_date')
              | map(attribute='image_id')
              | list
              | last 
          })
      }}
  loop: "{{ rhel8_amis.results }}"

- set_fact:
    vpc_result: "{{ vpc }}"

- name: Create VPC, subnet and SG for each region
  loop: "{{ vpc | dict2items }}"
  include_tasks: vpc.yml
  vars:
    region: "{{ item.key }}"
    vpc_data: "{{ item.value }}"

# TODO the VPC peering/routes does not scale to 3+ regions
- name: Create VPC peering
  ec2_vpc_peer:
    region: "{{ vpc_result | list | first }}"
    vpc_id: "{{ (vpc_result | dict2items | first).value.vpc_id }}"
    peer_region: "{{ vpc_result | list | last }}"
    peer_vpc_id: "{{ (vpc_result | dict2items | last).value.vpc_id }}"
    tags: "{{ resource_tags }}"
    wait: True
  when: vpc_result | dict2items | length > 1
  register: created_peering

- name: Accept peering connection from peer region
  community.aws.ec2_vpc_peer:
    region: "{{ vpc_result | list | last }}"
    peering_id: "{{ created_peering.peering_id }}"
    state: accept
  when: vpc_result | dict2items | length > 1
  register: vpc_peer

- name: Route table for peering
  ec2_vpc_route_table:
    vpc_id: "{{ (vpc_result | dict2items | first).value.vpc_id }}"
    region: "{{ vpc_result | list | first }}"
    subnets: "{{ (vpc_result | dict2items | first).value.subnets | list }}"
    purge_routes: False
    routes:
      - dest: "{{ (vpc_result | dict2items | last).value.cidr_block }}"
        vpc_peering_connection_id: "{{ created_peering.peering_id }}"
    tags: "{{ resource_tags | combine( { 'Name': 'Main Route Table', 'Cloud': 'AWS' } ) }}"
  when: vpc_result | dict2items | length > 1

- name: Reverse route table for peering
  ec2_vpc_route_table:
    vpc_id: "{{ (vpc_result | dict2items | last).value.vpc_id }}"
    region: "{{ vpc_result | list | last }}"
    subnets: "{{ (vpc_result | dict2items | last).value.subnets | list }}"
    purge_routes: False
    routes:
      - dest: "{{ (vpc_result | dict2items | first).value.cidr_block }}"
        vpc_peering_connection_id: "{{ created_peering.peering_id }}"
    tags: "{{ resource_tags| combine( { 'Name': 'Main Route Table', 'Cloud': 'AWS' } ) }}"
  when: vpc_result | dict2items | length > 1

- name: Create key pair using key_material
  amazon.aws.ec2_key:
    name: "{{ ssh_key_name }}"
    region: "{{ item }}"
    key_material: "{{ lookup('file', 'id_rsa_aws.pub') }}"
  loop: "{{ vpc | list }}"

- set_fact:
    vm_result: []

- name: Create EC2 instances for services
  include_tasks: instance.yml
  loop: "{{ vm + db_vm + eap_vm}}"
  loop_control:
    loop_var: instance
    index_var: vm_idx

- name: "Report of generated networking"
  debug:
    var: vpc_result

- name: "Report of generated instances"
  debug:
    var: vm_result
